<Query Kind="Program">
  <Namespace>System.Threading.Tasks</Namespace>
</Query>

void Main()
{
	var baseFolder = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.UserProfile), @"source\repos\coatsy\AoC2023");
	var dayFolder = @"Day08";
	//var inputFile = @"test.txt";
	//var inputFile = @"test2.txt";
	//var inputFile = @"test3.txt";
	var inputFile = @"input.txt";

	inputFile.Dump("Data file");

	var Nodes = new List<Node>();
	string directions;

	using (var file = File.OpenText(Path.Combine(baseFolder, dayFolder, inputFile)))
	{
		// read the directions
		directions = file.ReadLine();

		// and a blank line
		file.ReadLine();

		// now read the nodes
		while (!file.EndOfStream)
		{
			Nodes.Add(new Node(file.ReadLine()));
		}
	}

	// Now loop through the nodes and get the references for Left and Right
	foreach (var node in Nodes)
	{
		node.LeftNode = Nodes.FirstOrDefault(n => n.Id == node.Left);
		node.RightNode = Nodes.FirstOrDefault(n => n.Id == node.Right);
	}

	// Nodes.Dump();

	if (!(inputFile == @"test3.txt"))
	{
		var thisNode = Nodes.First(n => n.IsStart);
		var instructionNo = 0;

		while (!thisNode.IsEnd)
		{
			thisNode = thisNode.NextNode(directions[instructionNo % directions.Length]);
			instructionNo++;
		}

		instructionNo.Dump("Total steps for a single node");
	}

	if (inputFile == @"test3.txt" || inputFile == @"input.txt")
	{
		var nodeSet = Nodes.Where(n => n.Id[2] == 'A').Select(n => new NodeSteps { startNode = n.Id, steps = 0ul }).ToList();
		foreach (var ns in nodeSet)
		{
			ns.startNode.Dump();
			var foundZ = false;
			var zLoopCount = 0;
			var thisNode = Nodes.FirstOrDefault(n => n.Id == ns.startNode);
			while (true)
			{
				thisNode = thisNode.NextNode(directions[(int)(ns.steps % (ulong)directions.Length)]);
				ns.steps++;
				ns.loopCount += foundZ ? 1ul : 0ul;
				if (thisNode.Id[2] == 'Z')
				{
					if (foundZ)
					{
						break;
					}
					else
					{
						foundZ = true;
						ns.stepsToStartOfLoop = ns.steps;
					}
				}
			}
			
		}

		var allSteps = nodeSet.Select(n => n.loopCount).ToArray();

		var lcm = allSteps.Aggregate((a, b) => LCM(a, b));

		lcm.Dump("Total steps for parallel nodes");
	}

}

#region Generated by Bing AI
private static ulong LCM(ulong a, ulong b)
{
	return (a / GCD(a, b)) * b;
}

private static ulong GCD(params ulong[] numbers)
{
	if (numbers == null || numbers.Length == 0)
		throw new ArgumentException("At least one number must be provided.");

	ulong result = numbers[0];
	for (int i = 1; i < numbers.Length; i++)
	{
		result = GCD(result, numbers[i]);
	}

	return result;
}

private static ulong GCD(ulong a, ulong b)
{
	while (a != 0 && b != 0)
	{
		if (a > b)
			a %= b;
		else
			b %= a;
	}

	return a | b;
}

#endregion

// You can define other methods, fields, classes and namespaces here

public class Node
{
	public string Id;
	public string Left;
	public string Right;
	public Node LeftNode;
	public Node RightNode;

	public bool IsStart => Id == "AAA";
	public bool IsEnd => Id == "ZZZ";

	public Node(string nodeString)
	{
		Id = nodeString.Substring(0, 3);
		Left = nodeString.Substring(7, 3);
		Right = nodeString.Substring(12, 3);
	}

	public Node NextNode(char dir)
	{
		return dir == 'L' ? LeftNode : RightNode;
	}
}

public class NodeSteps
{
	public string startNode;
	public ulong steps;
	public ulong loopCount;
	public ulong stepsToStartOfLoop;
}

public static class ExtensionMethods
{
	public static bool AllFinished(this IEnumerable<Node> nodeSet)
	{
		return !nodeSet.Any(n => n.Id[2] != 'Z');
	}
}